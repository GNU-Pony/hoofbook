\input texinfo   @c -*-texinfo-*-

@c %**start of header
@setfilename hoofbook.info
@settitle GNU/Pony hoofbook
@afourpaper
@documentencoding UTF-8
@documentlanguage en
@finalout
@c %**end of header


@c metainfo for info dir
@dircategory General
@direntry
* hoofbook: (hoofbook).               The GNU/Pony hoofbook
@end direntry


@c dead fluttershy edition settings
@c @set DEAD_FLUTTERSHY_EDITION
@c @smallbook


@c define option index and bind it to variable
@c index and bind concept index to program index
@defindex op
@synindex op vr
@synindex cp pg


@c define abstract text
@macro abstract
@titlefont{Abstract}
@iftex
@*
@end iftex

@ifnottex
@quotation
@end ifnottex

Welcome to GNU/Pony! This hoofbook covers the installation and day
to day use of GNU/Pony. This manual is intendent as a glue-manual
and an overview manual, if gives you an overview of the system and
how subsystems can be configured and combined.

@c @ifclear DEAD_FLUTTERSHY_EDITION
@c If you prefer a dead fluttershy edition, you can order one from
@c ...
@c @end ifclear

@ifnottex
@end quotation
@end ifnottex
@end macro


@c define copyright notice
@copying
Copyright @copyright{} 2013 Mattias Andrée

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts. A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@c define top node and insert copyright notice for info and html version
@ifnottex
@node Top
@top The GNU/Pony hoofbook
@insertcopying

@abstract
@end ifnottex

@c define title page for tex version
@titlepage
@title The GNU/Pony hoofbook
@c @subtitle
@vskip 0pt plus 1filll
@c this way, it is centered exactly in pdf and approximently in dvi and ps
@c @center does not work for @image in dvi and ps
@multitable @columnfractions 0.15 0.7
@item @tab @center @image{obj/logo,200px}
@end multitable
@vskip 0pt plus 1filll
@author by Mattias Andrée (maandree)

@page
@center `What are hands?'
@vskip 0pt plus 1filll
@insertcopying

@c insert abstract section before the table of contents without messing up the page numbers
@page
@abstract

@end titlepage


@c print table of content in tex and html version
@contents



@menu
* Introduction::
* Conventions::
* Software packages::
* The boot process::

* GNU Free Documentation License::
* Concept and program index::
* Variable and option index::
@end menu



@node Introduction
@chapter Introduction

This chapter gives you a short introduction
to what GNU/Pony is.

@menu
* What is GNU/Pony?::
* Who is GNU/Pony for?::
@end menu



@node What is GNU/Pony?
@section What is GNU/Pony?

GNU/Pony is a GNU/Linux distribution that aims
to be extremely customisable and simple. A
GNU/Linux distribution is a combination of the
operativing system GNU and the operativing
system kernel Linux with additional tools to
make your life easier.

The GNU Project started in 1983 by Richard
Stallman, also known as rms (from Richard
Matthew Stallman) so that your can have
freedom when you use your computer.



@node Who is GNU/Pony for?
@section Who is GNU/Pony for?

GNU/Pony is for the computer enthusiast who
wants an operativing system tailored to her
own preferences down to that last detail and
does not mind building software from source.

GNU/Pony also includes some optional programs
designed for using in terminals with a
specific paradigm: ephemeral, the run during
as short of time as possible. so you have as
few running processes at the same time as
possible.



@node Conventions
@chapter Conventions

This chapter gives you a brief overview of
conventions used in GNU/Linux system and
other Unix-like systems.

@menu
* Filename conventions::
* Process name conventions::
@end menu



@node Filename conventions
@section Filename conventions

Configuration files are often called dotfiles,
specially if user private. This comes from the
fact that they have a `.' at the beginning of
their name the make them hidden.

Many of these are named with `rc' at the end,
exactly why is not known, but it could stand for
`run commands' or `run(time) configurations'.
Other configuration files, but seemingly
exclusively system configuration file, are
named with `tab' at the end, which stands for
`table'.

Directories with modular configuration files
are conventionally named with `.d' at the
end for `directory'.



@node Process name conventions
@section Process name conventions

Daemon processes are system processes that
run continuously in the background. These
are named with a `d' as the end.

Programs used for editing of sometimes named
with `ed' in the end for `editor'.



@node Software packages
@chapter Software packages

This chapter introduces the concept of
software packages to new users that do not
come from a GNU/Linux system or similar
system. It also gives an overview how it
this works specifically in GNU/Pony.

@menu
* What are software packages?::
* Package management in GNU/Pony::
* Package maintenance in GNU/Pony::
@end menu



@node What are software packages?
@section What are software packages?

Software packages is a concept this is
very popular for Free Software operativing
systems and distributions. Software packages
are basically scripts with instructions for
downloading and installing specific programs.
With a program called a package manager,
uninstallation, conflicts, dependencies and
updates can be handled in addition to
installations. Package managers also gives
you a method for find and install programs.
you may be interested in.

Distributions such as GNU/Linux have
collections of packages in what are called
package repositories. These are often
called ports trees if they are downloaded
to the users rather than remotely queried.



@node Package management in GNU/Pony
@section Package management in GNU/Pony

GNU/Pony's package repository is community
operated and consists for five Git branches:

@itemize
@item core: Recommended core packages
@item extra: Recommended packages
@item more: Additional packages
@item limbo: Removed packages
@item spool: Upcoming packages
@end itemize

The packages are then additional grouped
into categories.

The packages for GNU/Pony are called scrolls
or Spike scrolls. These are Python scripts, that
use a module called `dragonsuite' that provides
common functionality used when installing
programs, that provide metainformation for a
package and where to download the programs
source code and how to build and install it.

Users have the entires package repository
(ports tree) downloaded as a git repository.
This allows you to do local modificatios to
packages without losing the changes you have
made when the ports tree is updated.

The package manager for GNU/Pony is called
Spike, the command is @command{spike}.



@node Package maintenance in GNU/Pony
@section Package maintenance in GNU/Pony

GNU/Pony has a toolchain for maintaining packages.
Starswirl is a program that can be used to generate
Spike scrolls and Celestia templates, from Spike
scroll tempates. Celestia is meant to be invoked
periodically by @command{cron}, it is a program
that generates Spike scrolls from Celestia
templates when a new version of a program is
released. You choose to pipe Celestia to a program
that is some mannar notifies you about each line
it prints, but if you want to take the automation
on step further you can pipe it to the DragonFire
program that commits them to a git repository.

For Celestia you have a list of packages it should
maintain. For DragonFire you have a mapping to
which category a package belong. DragonFire should
also have a private clone of the package repository's
spool branch. You then manually push the repository
@footnote{Since you really should not store passwords
in plain text, but you caused, and do a push when
Celestia and DragonFire exited.}, test them and
cherry pick them to there appropriate branch.

GNU/Pony also have a package repository cannibaliser
called Sweetie Bot that crawls other GNU/Linux
distributions and converts them to Spike scrolls
(or optionally any other format).



@node The boot process
@chapter The boot process

This chapter gives you an overview of how a computers
boots, the entire way to your login manager. These
chapter are in the order of occurrence.

@menu
* The master boot record::
* The boot manager::
* The bootloader::
* The initial random access memory disc::
* The initialisation process::
@end menu



@node The master boot record
@section The master boot record

By default your BIOS will execute your storage
devices with the lowest port index. Execute
literally means that the entire content of
the device is treaded as machine code that
the computer runs.

The first 512 bytes in the device is called
the master boot record (MBR). The first 440
(or at most 446) bytes is the executed code,
and it ends with a halt instruction, so that
nothing beyond that is executed. The MBR also
contains information about the the zero to
four primary partitions. For this documentation
we are going to assume that this is this
construction is used, but it is not a technical
requirement, it is all up to the operating
system and boot manager.



@node The boot manager
@section The boot manager

The boot manager a program stored in the
absolute beginning of a storage device, and
is the program that the BIOS executes.

The mission in life for the boot manager
is to load the bootloader. It does this by
finding which primary partition@footnote{A
boot manager could technically also look at
logical and even extended paritions.} that
has a boot (also known as active) flag set.
Some boot managers supports multiple boot
flags and chooses either the first or last,
but partition table manipulators will often
unflag all flagged partitions when another
partition is flagged.

The bootloader is executed in the same way
as the boot manager, except it executes from
the beginning of the partition rather than
from the beginning of the disc.

SYSLINUX is a popular project that provides
a boot manager.



@node The bootloader
@section The bootloader

Some users, and some operating systems, choose
to hide the bootloader. It is the step where
the user can choose which operating system,
by its kernel, to start, it can also do chain
loading where it boots another bootloader or
boot manager.

The bootloader also lets you pass settings
to the operating systems kernel, such as
runlevel and root partition.

Technically a bootloader could open other
partitions, but traditionally it will either
chain load or execute files located in the
partition the bootloader is attached to.

SYSLINUX is a popular project that provides
a bootloader.



@node The initial random access memory disc
@section The initial random access memory disc

The initial random access memory disc (init
RAM disc, initrd, or initramfs@footnote{Initial
RAM filesystem}) is an optional auxiliary boot
process step. It is a file archive, stored in the
same parition as the kernel, that is mounted to
the random access memory (RAM).

The initrd provides boot instructions before
the root filesystem is mounted, the most important
parts are to located partitions and decrypting
encrypted file systems. When it is done it
swiches to the root filesystem and executes
/sbin/init, the initialisation process.

GNU/Pony's default initrd is simple called initram.



@node The initialisation process
@section The initialisation process

The initialisation process a the final step and
largest step in the boot process. In GNU/Pony's
default setup this process is provided by
SysVInit which is assisted by GNU/Pony's package
@w{pony-initialisation}.

SysVInit and pony-initialisation applies system
configurations, loads daemon processes and
starts your login manager.



@c full license text, this must never be removed
@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texinfo

@c BEGIN print indices
@node Concept and program index
@appendix Concept and program index
@printindex pg

@node Variable and option index
@appendix Variable and option index
@printindex vr
@c END print indices

@bye

