\input texinfo   @c -*-texinfo-*-

@c %**start of header
@setfilename hoofbook.info
@settitle GNU/Pony hoofbook
@afourpaper
@c @afivepaper
@documentencoding UTF-8
@documentlanguage en

@c dead fluttershy edition settings
@c @set DEAD_FLUTTERSHY_EDITION
@c @smallbook
@ifset DEAD_FLUTTERSHY_EDITION
@cropmarks
@setchapternewpage odd
@end ifset
@finalout
@c %**end of header


@c metainfo for info dir
@dircategory General
@direntry
* hoofbook: (hoofbook).               The GNU/Pony hoofbook
@end direntry



@c define option index and bind it to variable
@c index and bind concept index to program index
@defindex op
@synindex op vr
@synindex cp pg


@c define abstract text
@macro abstract
@titlefont{Abstract}
@iftex
@*
@end iftex

@ifnottex
@quotation
@end ifnottex

Welcome to GNU/Pony! This hoofbook covers the installation and day
to day use of GNU/Pony. This manual is intendent as a glue-manual
and an overview manual, it gives you an overview of the system and
how subsystems can be configured and combined. For details on
specific topics you should read that program's manual.

@c @ifclear DEAD_FLUTTERSHY_EDITION
@c If you prefer a dead fluttershy edition, you can order one from
@c ...
@c @end ifclear

@ifnottex
@end quotation
@end ifnottex
@end macro


@c define copyright notice
@copying
Copyright @copyright{} 2013 Mattias Andrée

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts. A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@c define top node and insert copyright notice for info and html version
@ifnottex
@node Top
@top The GNU/Pony hoofbook
@insertcopying

@abstract
@end ifnottex

@c define title page for tex version
@titlepage
@title The GNU/Pony hoofbook
@c @subtitle
@vskip 0pt plus 1filll
@c this way, it is centered exactly in pdf and approximently in dvi and ps
@c @center does not work for @image in dvi and ps
@multitable @columnfractions 0.15 0.7
@item @tab @center @image{obj/logo,200px}
@end multitable
@vskip 0pt plus 1filll
@author by Mattias Andrée (maandree)

@page
@center `What are hands?'
@vskip 0pt plus 1filll
@insertcopying

@c insert abstract section before the table of contents without messing up the page numbers
@page
@abstract

@end titlepage


@c print table of content in tex and html version
@contents



@menu
* Introduction::
* Philosophy::
* Installation::
* Conventions::
* Software packages::
* The boot process::
* The login process::

* GNU Free Documentation License::
* rms transcriptions::
* Concept and program index::
* Variable and option index::
@end menu



@node Introduction
@chapter Introduction

This chapter gives you a short introduction
to what GNU/Pony is.

@menu
* What is GNU/Pony?::
* Who is GNU/Pony for?::
* License information::
@end menu



@node What is GNU/Pony?
@section What is GNU/Pony?

GNU/Pony is a GNU/Linux distribution that aims
to be extremely customisable and simple. A
GNU/Linux distribution is a combination of the
operating system GNU and the operating
system kernel Linux with additional tools to
make your life easier.

The GNU Project started in 1983 by Richard
Stallman, also known as rms (from Richard
Matthew Stallman) so that your can have
freedom when you use your computer (not just
computer programs).



@node Who is GNU/Pony for?
@section Who is GNU/Pony for?

GNU/Pony is for the computer enthusiast who
wants an operating system tailored to her
own preferences down to that last detail and
does not mind building software from source.

@cindex ephemeral
@cindex paradigm
GNU/Pony also includes some optional programs
designed for using in terminals with a
specific paradigm: ephemeral, to run during
as short of time as possible, so you have as
few running processes at the same time as
possible.



@node License information
@section License information
@cindex licenses of GNU/Pony

GNU/Pony is an operating system distribution
with contains a few layers, which are licensed
differenly:

@table @asis
@item The boot manager
@cindex boot manager
The default boot manager is provided by SYSLINUX
which is licensed under the GNU General Public
License version 2.

@item The bootloader
@cindex bootloader
The default bootloader is provided by SYSLINUX
which is licensed under the GNU General Public
License version 2.

@item The kernel
@cindex kernel
The default kernel is currently Linux which is
licensed under the GNU General Public
License version 2 amoung other licenses.

@item The core userland
@cindex code userland
The default core userland is almost exclusively
GNU, a large collection of programs, which is
licensed under the GNU General Public License
version 3 and few other licenses.

@item The distribution userland
@cindex distribution userland
The GNU/Pony userland is the programs written
specifically for GNU/Pony. They are licensed
under the GNU General Public license 3 and the
GNU Affero General Public license 3, with parts
being licensed under the GNU All Permissive License.

There are however two exceptions:
@itemize @bullet
@item netcfg: New BSD License (3-clause BSD License)
@item miscellaneous:
Do what the fuck you want to public license, version 2
@end itemize

@item The ports tree
@cindex package repository
@cindex ports tree
The GNU/Pony package repository is licensed under
the GNU General Public License version 3, but the
individual scrolls are licensed under the GNU All
Permissive Licenses, but it is believed that
copyright is not forced upon them or that they
can even copyrighted at all.

The package repository is however install copyrighted
programs that can be of vertially any license. But
you have to opt out from strict freedom control to
install non-free programs, even if they are shareable.

@end table

@cindex Free Software
In short: with the exception for parts of the interim
default kernel, GNU/Pony is entirely Free Software,
but only almost entirely Open Source (but it does not
aim to be Open Source, only to be Free Software.)



@node Philosophy
@chapter Philosophy

This chapter describes the collection of philosophies
that makes up GNU/Pony.

@menu
* Philosophy of the GNU Project::
* Unix philosophy::
* Worse is better::
* Philosophy of the GNU/Pony project::
@end menu



@node Philosophy of the GNU Project
@section Philosophy of the GNU Project
@cindex GNU Project
@cindex the GNU Project
@cindex Free Software
@cindex philosophy

Free Software means that the software's users have freedom
(it is not an issue about price.) The GNU operating system
was developed so that users can have freedom in their
computing. It is not just a matter of being able to share
software solutions, it is matter of having freedom in
computer space, both in softare and in hardware.

A program is Free Software if the program's users have the
four essential freedoms:

@itemize @bullet
@item @i{Freedom 0:}
The freedom to run the program, for any purpose as you wish.
@item @i{Freedom 1:}
The freedom to study how the program works, and change it so
it does wait you wish.
@item @i{Freedom 2:}
The freedom to redistribute copies so you can help your
neighbour.
@item @i{Freedom 3:}
The freedom to contribute to your community by distributing
copies of your modified versions when you which.
@end itemize



@node Unix philosophy
@section Unix philosophy
@cindex philosophy
@cindex unix

@smallquotation
`Unix is simple. It just takes a genius to understand
its simplicity.' – Dennis Ritchie
@end smallquotation

@smallquotation
`Unix is user-friendly. It just isn't promiscuous about
which users it's friendly with.' – Steven King
@end smallquotation


@table @asis
@item Modularity
@cindex modularity
@cindex simplicity
Systems should be build of small programs connected
by a well defined interface. This simplifies debugging,
reduces complexity, increases readability and makes it
easier to replace or extend parts ot the system.
@item Composition
@cindex composition
@cindex simplicity
Programs should be written so that they can communicate
easily with other programs. This enables cannibalisation
by invocation, reduces the need of code cannibalisation
or reinvention, reduces the complexity of a system, makes
it easier to replace parts ot the system, and enables to
user to perform actions far beyond what the developer
could have imagined.
@item Separation
@cindex separation
@cindex simplicity
Mechanisms of the programs from the policies of the
programs should be separated into a front-end interface
and back-end engine that interface communicates with.
@item Representation
@cindex representation
@cindex simplicity
When faced with having to choose, make the data more
complicated rather than the procedural logic.
@item Generation
@cindex generation
@cindex automatication
Write abstract high-level programs that generate code,
this reduces development time and reduces bugs.
@item Diversity
@cindex diversity
Programs should be designed to be flexible. This allows
them to be used in other ways than their developers
intended.
@item Extensibility
@cindex extensibility
Write extensible protocols to allow for easy plugins
without modification to the program's architecture.
@end table



@node Worse is better
@section Worse is better
@cindex unix
@cindex philosophy
@cindex worse is better
@cindex better is worse

@table @asis
@item Simplicity
@cindex simplicity
Simplicity is the most important consideration in a
design, both in implementation and interface
@item Correctness
@cindex correctness
The design must be correct in all observable aspects,
but it is better to be simple.
@item Consistency
@cindex consistency
The design should not be overly inconsistent, it can
be sacrificed for simplicity, but it is better to drop
less common circumstances.
@item Completeness
@cindex completeness
The design should cover as many situations as is
practical. Completeness can be sacrificed in favour
of any other quality and must be sacrificed whenever
implementation simplicity is jeopardised, but
consistency can be sacrificed to achieve completeness;
especially worthless is consistency of the interface.
@end table



@node Philosophy of the GNU/Pony project
@section Philosophy of the GNU/Pony project
@cindex GNU/Pony
@cindex philosophy

@table @asis
@item Documentation
@cindex documentation
Every feature and internal plumbing of a
program must be documented as well as
interresting use tricks. A program is nothing
without documentation. @command{info} is
primary, @command{man} is tertiary.
@item Unused RAM is wasted RAM
@cindex wasted RAM
Nopony ever fills her entires RAM; programs
do no need to minimise RAM, it often makes
the program more complex or less readable.
Not utilising the computers RAM, especially
in these minute quantites, is a waste of RAM.
@item Wasted RAM is still wasted RAM
@cindex ephemeral
@cindex wasted RAM
Programs should still free memory it does
not require any more and never will, unless
it makes to program overly complex. Ephemeral
programs need not bother about this as they
there memory will be freed soon anyway
(but do free everything when the program
exits to help debugging.)
@item Reduce complexity not overhead
@cindex time complexity
@cindex complexity, time
@cindex overhead
@cindex program speed
Do not rewrite your programs in C or otherwise
reduce overhead, it is time complexity that is
important: use efficent algorithms, instruction
flows, and data structions that do not make the
program overly complex. The only except if is
the algorithm cannot be change, is intensive,
and can be considerably more efficient with a
faster language and code tweaks; for example
cryptographic hashing algorithms.
@item Extensibility
@cindex extensibility
Aim for unlimited extensibility, this is often
closely approximable with onion functions.
@item Customisibility
@cindex customisibility
Aim for unlimited customisibility, this is often
closely approximable with extension and
configuration files that are scripts that are
sourced.
@item Portability at compile time
@cindex portability
Programs should try to utilise the operating
system as much as possible, portability can
be implemented as compile rather than runtime.
@item Minimalism
@cindex simplicity
@cindex minimalism
Programs should be as small as possible and
be extended with extensions.
@end table



@node Installation
@chapter Installation

In this chapter you will learn how to install
GNU/Pony, and get information about details
you should thinks about when installing your
system.

@menu
* Partitioning your harddrive::
@end menu


@node Partitioning your harddrive
@section Partitioning your harddrive

@cindex partitions
When installing your system you should think
about how you want to partition your system.
Exactly how you want to this depends on your
requirements and resources.

@cindex @file{/boot}
@cindex kernel image
@cindex initramfs
@cindex initrd
@cindex bootloader
@cindex chainloading
It is highly recommended to have a partition
for @file{/boot}, the directory containing
the bootloader (see @ref{The bootloader} for
more information), and the kernel image and the
early initialisation image (for more information
see @ref{The initial random access memory disc}).
If you only install one kernel to this
partition, 50 MB will do you quite well. This
partition needs to be a primary partition unless
it is chainloaded from another bootloader.
The size of the a Linux kernel image, depends
on how it is configures, but it is unlikely that
is exceeds 5 MB. The early initialisation image
also unlikely to exceed 5 MB, but a fallback
for this image can be 20 MB. However, it is
recommended to use even 100 MB or even 200 MB,
to be safe, you never now if you want to install
additional images or if the images will grow
larger over the years, an installation of a
rolling release distribution will never need to
be reinstalled and can last forever.

@cindex extended partition
@cindex primary partition
@cindex logical partition
@cindex bootloader
@cindex chainloading
To maximise the flexibility of your partitions,
it recommended to make an extended partition of
the remaining disc space. The bootloader needs
to be in a primary parition to be started by the
boot manager, and if you are using chainloading
it is easiest to chainload into primary paritions,
but beyond that all partitions can be logical.
A primary partition is a regular partition, an
extended partition is a special type of primary
partition than contains additional partitions,
logical partitions. You can only have at most one
extended partition. Including your extended
partition you can only have four primary
partitions, but you can have an unlimited number
of logical partitons@footnote{With the exception
that the kernel as a limited number of major–minor
number pairs for block devices and only few of
then are for hard drives and partitions}.

@cindex @file{/}
@cindex @file{/usr}
@cindex @file{/usr/local}
@cindex @file{/usr/games}
@cindex @file{/usr/local/games}
@cindex @file{/opt}
@cindex @file{/home}
@cindex @file{/srv}
@cindex @file{/etc}
@cindex @file{/var}
@cindex @file{/info}
@cindex @file{/share}
How to best partition the rest of the system is
debated. What you have now to consider is the
directories @file{/}, @file{/usr}, @file{/usr},
@file{/usr/local}, @file{/usr/games},
@file{/usr/local/games}, @file{/opt},
@file{/home}, @file{/srv}, @file{/etc},
@file{/var}, @file{/info} and @file{/share}.
@file{/usr/games} and @file{/usr/local/games}
were initialially introduces because games
are typically large and the harddrives was
not too big back in the days; today not that
many distrubtions even have them, and we do
not recommend creating separate partitions
for them. So the remain directories are:

@table @file
@item /
Essential programs.

@item /usr
Non-essential programs. Today many
distributions symlinks @file{/bin}
to @file{/usr/bin}, @file{/sbin}
to @file{/usr/sbin} and @file{/lib}
to @file{/lib}, but even before that
few recommended to put it on a separate
partition.

@item /usr/local
Programs not included in the distribution:
private software and software not yet
included in the package repostory.

@item /opt
Serves as hosting directory for the same
category of programs as @file{/usr}, but
self-contained and large cases. Because
of this and the size of today's harddrives
it is recommended that it is not separated
from @file{/usr}.

@item /home
User home directories. It is generally
agreed that this directory is placed on its
own partition because you do not want to
lose files because you forget to backup
dotfiles or lose it if the system partition
gets corrupted. There is however no sense
in separating it just so you can have two
or more systems sharing it, as the
configuration by the dotfiles can cause
problems.

@item /srv
Directory for services hosted by the machine.

@item /etc
@cindex initramfs
@cindex initrd
Host specific system-wide configurations.
Separating this directory to a partition
separate from @file{/} is tricky but possible:
it must be mounted in the early boot process.

@item /var
Variable data files.

@item /info
GNU/Pony directory for administrated shared files.

@item /share
GNU/Pony directory for user shared data.

@end table

This is how we recommend that you partition
your system, in four partitions:

@table @asis
@item @file{/}, @file{/var} and @file{/etc}
One partition for the essentials, and the variable
data including the system logs.

@item @file{/usr} and @file{/opt}
One partition for non-essential programs.

@item @file{/usr/local}, @file{/srv}, @file{/home}, @file{/info} and @file{/share}
One partition for local and user files.

@item Spare partition
A spare partition of the same size as that
of @file{/}. This allows you to backup your
essentials when you know that it is in a
good state, allowing you to boot into it if
@file{/} breaks or gets corrupted.
Additionally this allows you to temporarly
use another partition for @file{/} and
reformat your actual @file{/} into a newer
filesystem without reinstalling your system.

@end table

This partitioning setup is unconventional not
straight forward how to setup. You can
create a hidden directory named @file{~/.parts},
in which you can create two mountpoint
directories: @file{usr}, @file{local},
which can be used from creating @file{/usr}
and @file{/opt} and @file{/usr/local},
@file{/srv}, @file{/home}, @file{/info}
and @file{/share} as symlinks to inner
directories you need to create.

However, if your @file{/usr} and @file{/opt}
directories are not going to be that large,
it makes more sense to combine that partition
with that of @file{/}.

@pindex UPX
Provided that you do not have too many
local and user files. A GNU/Linux installation
can be quite small. 5 GB can actually be
enough, 10 GB to be safe, if you do not
have that many large programs or too many
programs. A 50 GB partition for all program
can be quite the challenge to deplete,
80 GB is practically impossible to fill.
This can largely be credited to the heavy
use of dynamic linking, and it even possible
to compress executables with UPX, strip
unused symboles for executables and to
optimise the compilation of problem to
minimise the size of the create executable.




@node Conventions
@chapter Conventions

This chapter gives you a brief overview of
conventions used in GNU/Linux system and
other Unix-like systems.

@menu
* Filename conventions::
* Process name conventions::
@end menu



@node Filename conventions
@section Filename conventions

@cindex dotfiles
@cindex configuration files
Configuration files are often called dotfiles,
especially if user private. This comes from the
fact that they have a `.' at the beginning of
their name the make them hidden.

@cindex @file{-rc}
@cindex @file{-tab}
Many of these are named with `rc' at the end,
exactly why is not known, but it could stand for
`run commands' or `run(time) configurations'.
Other configuration files, but seemingly
exclusively system configuration file, are
named with `tab' at the end, which stands for
`table'.

@cindex @file{-.d}
Directories with modular configuration files
are conventionally named with `.d' at the
end for `directory'.



@node Process name conventions
@section Process name conventions

@cindex @command{-d}
@cindex daemon processes
@cindex system processes
@cindex background processes
Daemon (pronounced exactly as `demon',
no fancy diphthong) processes are system
processes that run continuously in the
background. These are named with a `d'
in the end.

@cindex @command{-ed}
Programs used for editing of sometimes named
with `ed' in the end for `editor'.



@node Software packages
@chapter Software packages

This chapter introduces the concept of
software packages to new users that do not
come from a GNU/Linux system or any similar
system. It also gives an overview how
this works specifically in GNU/Pony.

@menu
* What are software packages?::
* Package management in GNU/Pony::
* Package maintenance in GNU/Pony::
@end menu



@node What are software packages?
@section What are software packages?

@cindex package manager
Software packages is a concept this is
very popular for Free Software operating
systems and distributions. Software packages
are basically scripts with instructions for
downloading and installing specific programs.
With a program called a package manager,
uninstallation, conflicts, dependencies and
updates can be handled in addition to
installations. Package managers also gives
you a method for finding and installing programs
you may be interested in.

@cindex package repository
Distributions such as GNU/Linux have
collections of packages in what are called
package repositories. These are often
called ports trees if they are downloaded
to the users rather than remotely queried.



@node Package management in GNU/Pony
@section Package management in GNU/Pony
@cindex installing software
@cindex uninstalling software
@cindex updating software

GNU/Pony's package repository is community
operated and consists for five Git branches:

@itemize
@item core: Recommended core packages, high priority support
@item extra: Recommended packages, medium priority support
@item more: Additional packages, low priority support
@item limbo: Removed packages, no support
@item spool: Upcoming packages
@end itemize

The packages are further grouped into categories.

@cindex scrolls
@cindex Spike scrolls
@cindex dragonsuite
The packages for GNU/Pony are called scrolls
or Spike scrolls. These are Python scripts, that
use a module called `dragonsuite' that provides
common functionality used when installing
programs, that provide metainformation for a
package and where to download the programs
source code and how to build and install it.

@cindex ports tree
Users have the entires package repository
(ports tree) downloaded as a Git repository.
This allows you to do local modificatios to
packages without losing the changes you have
made when the ports tree is updated.

@pindex @command{spike}
The package manager for GNU/Pony is called
Spike, the command is @command{spike}.



@node Package maintenance in GNU/Pony
@section Package maintenance in GNU/Pony

@pindex @command{starswirl}
@pindex @command{cron}
@pindex @command{celestia}
@cindex Spike scroll templates
@cindex Celestia templates
@cindex automation, package maintenance
@cindex @command{dragonfire}
GNU/Pony has a toolchain for maintaining packages.
Starswirl is a program that can be used to generate
Spike scrolls and Celestia templates, from Spike
scroll templates. Celestia is meant to be invoked
periodically by @command{cron}, it is a program
that generates Spike scrolls from Celestia
templates when a new version of a program is
released. You can choose to pipe Celestia to a program
that is some manner notifies you about each line
it prints, but if you want to take the automation
on step further you can pipe it to the DragonFire
program that commits them to a Git repository.

For Celestia you have a list of packages it should
maintain. For DragonFire you have a mapping to
which category a package belong. DragonFire should
also have a private clone of the package repository's
spool branch. You then manually push the repository
@footnote{Since you really should not store passwords
in plain text, but you could, and do a push when
Celestia and DragonFire exited.}, test them and
cherry pick them to their appropriate branch.

@cindex cannibalisation, package repository
@cindex package repository cannibalisation
@pindex @command{sweetiebot}
GNU/Pony also have a package repository cannibaliser
called Sweetie Bot that crawls other GNU/Linux
distributions and converts them to Spike scrolls
(or optionally any other format). As a GNU/Pony user
or system administrator you do not need to know about
Sweetie Bot. Sweetie Bot has a module for each
foreign package repository it knows about, and each
module is only supposted to be ran by one user world
wide, a GNU/Pony developer. Sweetie Bot could also
be ran by developers for other distributions.



@node The boot process
@chapter The boot process

This chapter gives you an overview of how a computer
boots, the entire way to your login manager. These
section are in the order of occurrence when booting
the computer.

@menu
* The master boot record::
* The boot manager::
* The bootloader::
* The initial random access memory disc::
* The initialisation process::
@end menu



@node The master boot record
@section The master boot record

@cindex BIOS
By default your BIOS will execute your storage
devices with the lowest port index. Execute
literally means that the entire content of
the device is treated as machine code that
the computer runs.

@cindex MBR
@cindex master boot record
The first 512 bytes in the device is called
the master boot record (MBR). The first 440
(or at most 446) bytes is the executed code,
and it ends with a halt instruction, so that
nothing beyond that is executed. The MBR also
contains information about the zero to
four primary partitions. For this documentation
we are going to assume that this is the
construction that is used, but it is not a
technical requirement, it is all up to the
operating system and boot manager.



@node The boot manager
@section The boot manager

@cindex boot manager
The boot manager a program stored in the
absolute beginning of a storage device, and
is the program that the BIOS executes.

@cindex boot manager
@cindex bootloader
@cindex boot flag
@cindex active flag
@cindex boot partition
@cindex bootable partitions
@cindex active partition
The mission in life for the boot manager
is to load the bootloader. It does this by
finding which primary partition@footnote{A
boot manager could technically also look at
logical and even extended partitions.} that
has a boot (also known as active) flag set.
Some boot managers supports multiple boot
flags and chooses either the first or last,
but partition table manipulators will often
unflag all flagged partitions when another
partition is flagged.

The bootloader is executed in the same way
as the boot manager, except it executes from
the beginning of the partition rather than
from the beginning of the disc.

@pindex SYSLINUX
SYSLINUX is a popular project that provides
a boot manager.



@node The bootloader
@section The bootloader

@cindex bootloader
@cindex chain loading
Some users, and some operating systems, choose
to hide the bootloader. It is the step where
the user can choose which operating system,
by its kernel, to start, it can also do chain
loading where it boots another bootloader or
boot manager.

The bootloader also lets you pass settings
to the operating systems kernel, such as
runlevel and root partition.

Technically a bootloader could open other
partitions, but traditionally it will either
chain load or execute files located in the
partition the bootloader is attached to.

@pindex SYSLINUX
SYSLINUX is a popular project that provides
a bootloader.



@node The initial random access memory disc
@section The initial random access memory disc

@cindex inital RAM disc
@cindex initrd
@cindex initramfs
The initial random access memory disc (init
RAM disc, initrd, or initramfs@footnote{Initial
RAM filesystem}) is an optional auxiliary boot
process step. It is a file archive, stored in the
same partition as the kernel, that is mounted to
the random access memory (RAM).

@pindex @command{init}
@pindex @command{/sbin/init}
The initrd provides boot instructions before
the root filesystem is mounted, the most important
parts are to locate partitions and decrypting
encrypted file systems. When it is done it
switches to the root filesystem and executes
/sbin/init, the initialisation process.

@pindex initram
GNU/Pony's default initrd is simply called initram.



@node The initialisation process
@section The initialisation process

@cindex initialisation process
@pindex SysVInit
@pindex pony-initialisation
The initialisation process is the final step and
largest step in the boot process. In GNU/Pony's
default setup this process is provided by
SysVInit which is assisted by GNU/Pony's package
@w{pony-initialisation}.

@cindex daemon processes
@cindex login manager
SysVInit and pony-initialisation applies system
configurations, loads daemon processes and
starts your login manager.



@node The login process
@chapter The login process

@cindex login
@cindex login management
@cindex login session
This chapter introduces you to how login
management works in GNU/Pony and other
Unix-like operating systems.

@menu
* Teletypewriter login management::
* Graphical login management::
@end menu
@c TODO write about login sessions



@node Teletypewriter login management
@section Teletypewriter login management

@cindex runlevel
@cindex runlevel 3
By default GNU/Pony boots into runlevel 3,
this is a specification on what you want
your operating system to start when it
boots. Runlevel 3 implies multiple virtual
terminals (teletypewriters) but no graphics
started by default.

@pindex @command{getty}
@pindex @command{login}
@pindex util-linux
The login management for teletypewriters
are divided into two programs, the getty
and the login programs. `getty' is portmanteau
of `get' and `TTY'@footnote{TTY is an
abbreviation of teletypewriter.}, its
purpose is gain access to a terminal and
start the login program which performs
the login. It is always the login program
that reads the passphrase and verifies it,
but which program that reads the username
depends on which programs you choose as
your getty and login programs.

@pindex @command{agetty}
If choose @command{agetty} and @command{login}
from util-linux, which is the default on
GNU/Pony, it is @command{agetty} that reads
the username, but @command{login} is fully
capable to do so.

@pindex @command{gates-of-tartaros}
If you choose GNU/Pony's @command{gates-of-tartaros}
instead of @command{agetty}, it will also
read the username, but fore better reasons.
@command{gates-of-tartaros} is capable to
start @command{ssh} instead of @command{login}
if the user specifies which host she wants
to log in into, and to lock the terminal for
ten minutes if it detects that somepony is trying
to cheat its way through user authentication.
@command{gates-of-tartaros} is also extensible,
and comes with an extension that allows the
user to use upper case letter when typing the
username and in such case behave like Unix and
configure the terminal to print everything
(that is ASCII) in upper case, which however
breaks colouring.

@pindex @command{cerberus}
@pindex @command{libpassphrase}
You can also choose to use GNU/Pony's
@command{cerberus} instead of @command{login},
either by linking @file{/usr/local/sbin/login}
to it (or by other means put it into @var{PATH}
with higher precedence than @command{login}) or
by configuring @command{gates-of-tartaros} to
use @command{cerberus} instead of @command{login}.
@command{cerberus} is not capable of ready
the username, but is more configurable (but only
compile-time configurable), minimal, and uses
libpassphrase which allows you to configure how
the terminal behaves when the program reads a
passphrase.



@node Graphical login management
@section Graphical login management

@cindex runlevel
@cindex runlevel 5
@cindex display manager
By default GNU/Pony boots into runlevel 3,
which does not start graphics by default.
Booting into runlevel 5 instead will start
graphics by default, and you will graphical
login manager which is what you will be used
to if you come from a distribution of
operating system that is more promiscuous
about with whom it is user-friendly.

A graphical login manager is called a
`display manager', which is a misnomer. It
does not really manage the display, that
is done by the display server.

@pindex XDG
@pindex SLiM
@pindex systemd
@pindex PAM
@pindex Pluggable Authentication Modules
GNU/Pony does not have a default graphical
login manager, but popular graphical login
managers include XDG and SLiM and login
managers designed for specific desktop
environments. Before commiting to a graphical
display manager you should make sure it works
problem free with systemd if you also choose
to use systemd. Issues by be caused by use of
Pluggable Authentication Modules (PAM) that is
incompatible with systemd.

@pindex desktop
A display manager graphical (login manager)
is three core missions: to start the display
server, to ask for username and passphrase and
login the user, and to as the user which
desktop start and start it.



@c full license text, this must never be removed
@node GNU Free Documentation License
@appendix GNU Free Documentation License
@include fdl.texinfo



@node rms transcriptions
@appendix rms transcriptions

This appendix is a collection of transcriptions
form talks by Richard Stallman; always informative,
and sometimes fun.

@menu
* Free Software is not Open Source::
* GPL version 3 release speech::
* Virus-free GNU+Linux::
@end menu



@node Free Software is not Open Source
@section Free Software is not Open Source

@c https://www.youtube.com/watch?v=FpAKasXdrXI

@smallquotation
Richard I so not think requires any
introduction to this audience, but I
he is the… almost the certainly the
father of the modern Open Source
movement… <interrupted>
@end smallquotation

No, absolutely not! If am the father of
Open Source it was done by artificial
insemination using @emph{stolen} sperm.
I am @emph{not} a supporter of Open Source,
I do @emph{not} agree with the basic values
of Open Source, I do @emph{not} try to
participate Open Source activities,
and when anyone refers to my work with
that term I take offence. You really
shouldn't have done that!
@smallquotation
Apologies!
@end smallquotation
You should have known better!
@smallquotation
And I do. And I think that is actually
a point I would like you to speak on
<unintelligible>.
@end smallquotation
The sad thing is that most people thin
that they are very familiar with my work
and what they think my work is, its
something I do not even agree with.
Completely wrong. I founded the Free
Software movement, a movement for computer
users' freedom. Freedom to control your
own computing and freedom to cooperate
with other people. These are freedoms
that I believe every computer user is
entitled to. It must never be taked away,
they should be inalienable rights for
the user of software. That is the idea
of the software movement. Non-free
sofware, proprietary software, keeps
users divided and helpless. Divided
because they are forbidden share with
anyone else and helpless because they
do not have the source code so that
can't control what the software does.
And in fact they are at the mercy of
the developer who does control it.
So a non-free software functions as
an instrument of the power of its
developer, power over the users. This
is an unjust social system that I
which to wipe out from the world.
That is the aim of the Free Software
movement. In order for every user
to have freedom that means there most
be no freedom denying software.



@node GPL version 3 release speech
@section GPL version 3 release speech

@c https://www.youtube.com/watch?v=E5G7FU5j2Uc
@c https://www.youtube.com/watch?v=KZNUVgPQpl8

Can I go to sleep now?

@smallquotation
Sure(<unintelligible>?) go ahead.
@end smallquotation

I guess I have to give a speech first.
I'm happy to say that we are actually
releasing GPL version 3 today, right
now I beleave, during this speech.
It is becoming official and people can
start to release software under GPL
version 3.

It has been essentially sixteen years
since GPL version 2 came out. We didn't
it would be this long before we made
the next version. I will try to attend
to future upgrade needs more quickly;
we won't wait more then a decade this
time.

But what is so important about GPL
version 3? Well first of all what is
the GPL for, what's its purpose. I
designed the GNU General Public License
for a very simple purpose: to defend
the freedom of @emph{every} user of a free
program. Not all free programs to this,
there are free programs that are release
under other licenses that are lax and
permissive, that allow modified version
to be made non-free. Some even allow…
just compiling it is enough excuse to
make it non-free; and what happens then?
The software may be very popular, it
may be powerful and reliable, but it
fails to deliver freedom to the users.
So the GNU General Public License is
designed to make sure that everyone how
gets the software also gets the essential
freedoms that the user of software
must have. These are:

@itemize @bullet
@item
Freedom 0, the freedom to run the
program as you wish.

@item
Freedom 1, the freedom to study the
source code and change it so it does
what you wish.

@item
Freedom 2, the freedom to help your
neighbour, which is the freedom to
distribute exact copies up to and
including republication when you wish.

@item
Freedom 3, the freedom to contribute
to your community, the freedom to
distribute copies of your modified
versions up to and including
republication when you wish.
@end itemize

These are the freedoms necessary so we
can control our own computing and be good
helpful members of our communities; and
together they give us democratic control
over what our software does.

Only with a license @emph{like} the GNU GPL
do the users have these for freedoms.
@emph{But} the advisories of freedom don't
stand still. The thought of new ways to
separate users from their freedom since
GPL version 2 came out. So we have had to
find ways to block them from doing this
in order to make sure the GPL continues
to achive what have always been its goal.
For instance, there is a practice we call
tivoisation after the product that began
it. The TiVo contains software that were
released under the GPL version 2, and
they comply --- formally --- with the
requirements of GPL version 2. But it
doesn't do the user of the TiVo any good.
Yes, the user can get the source code
for that software, but if the user tries
to change it and compile it and install
it into the TiVo it won't run. It's
@emph{guaranteed} not to run, and that is
no accident, the TiVo contains special
circuitry to check the signature of the
program and if it has been modified at
all then it shuts down. Now why would
they do a thing like this? The reason
is not innocent, the reason is because
the TiVo designed to restrict the user
and spy on the user. Nasty malicious
features. And they want to make sure
the user can't get rid of these nasty
features in the most natural way.
The way users are suppost to be able
to do with Free Software.

So GPL version 2 blocks this practice.
Sorry GPL version @emph{3} blocks this
practice! It says that if you distribute
binaries in a product to consumers
that you got to provide them with
whatever information is sufficient so
that they can install and run their
modified version in the products they
bought.

This is another variation of tivoisation.
Which is treacherous computing. That is
were the computer is designed so that a
website that you try to talk to can tell
whether you are running the officially
approved software or your own modified
version. And if you are running your own
modified version then it says they do
not trust you, so you are not allowed to
talk to the website. Well, with GPL version
3 that is not allowed either! They have
to provide you with information sufficient
to install your modified versions so that
they can functions just as the <stumbling>
original version would have done unless
your change is to make it do something
else. They are not allowed to distribute
it in such a way that the mere fact that
you modified it prevents it from
functioning the way the original version
would have. So we've blocked both varients
of this way of turning freedom number 1,
the freedom to study and change the
source code and make the program do what
you wish into a sham.

Another threat to our freedom comes from
software patents. I'm sure you've heard
about the Novell–Microsoft deal, which as
dangerous because effectively Novell is
going to pay Microsoft to give custumers
protection from some of Microsoft's
patents. Well, if Microsoft or anyone can
make users pay for the privilege of
running Free Software that takes away
freedom 0, the freedom to run the program
as you wish. We can't sit idly by and let
that happen. Now GPL version 2 hade a
change in it from GPL version 1 to protect
us against use of software patents to
make the program effectively non-free.
But it only applies to when the distributor
gets a patent license. Well, in the
Novell–Microsoft deal they were clever
and Microsoft did not give Novell a patent
licenses. So they slipped through this
crack in GPL version 2. Well, in GPL
version 3 we do not have this crack
anymore, such deals are not allowed.
@emph{However}, instead of simply saying that
Novell cannot distribute GPL version 3
coverted programs under their deal, we
found a cleverer thing to do with it:
when Microsoft upgrades to versions that
are covered by GPL version 3, GPL version
3 will extend this patent protection
from the customers of Novell to everybody
that uses those programs. Effectively
we found a way to turn that deal against
Microsoft and make it backfire. So it is
extremely important for Free Software
to upgrade the license to GPL version 3,
so that Microsoft… <correcting> Novell
will in the cause of time put in the new
versions and thus our community will get
this benefit. It has to be done fairly
soon, because if we wait @emph{too} long
Microsoft may distribute all its coupons
and then we won't be able to turn the
deal against them anymore. So get your
programs relicensed @emph{soon}, it is very
important! We expect @emph{all} the maintainers
of GNU software to relicense in the next
few months, it is important. But other
Free Software developers should also
relicense. There will be people how ask
you not to do so. A minority of our
community seems to be very angry about
GPL version 3; and when we try to probe
to find out their motives, it usually
turns out that they disagrees with the
goals of the GNU GPL, the goal of
guaranteeing freedom for every user.
Please, we people that holds those
views ask you to leave users' freedom
vulnerable, don't listen to them, defend
the freedom users' freedom, that's
imporant. And even if there are people
that who would ask us not to do it,
we got to do it. We have to defend the
users' freedom against these threats.

There are of cause many other advantages
in GPL version 3: compatibility with
the Apache license is one, better
internationallisation is another.
You'll also find that its termination
conditions work much better in the case
of a distributor of an entire GNU+Linux
distribution who makes a mistake and
thus violates the GPL for thousands of
programs at once and of cause wants to
correct it. With GPL version 2 those…
<correcting> that person who made a
mistake has to… <correcting> loses
the licenses permanently for every
program from every copyright holder
and has to the go and beg forgiveness
from everyone, which is not feasible.
But with GPL version 3 if thay correct
the mistake and the copyright holders
do not complain in 60 says then they
are in the clear. So they only have
to negotiate with those that actually
did complain. Assuming of cause that
they are sincere people and they
correct their mistake. We are still
in a good position to enforce the
license against anyone how intends
to violate it and does not correct
a mistake. So… GPL version 3 will
help our community any many ways…
and I urge people to upgrade to it.

Thank you!



@node Virus-free GNU+Linux
@section Virus-free GNU+Linux

@c  https://www.youtube.com/watch?v=Kfli_e923o4

@smallquotation
They say that GNU systems, or GNU/Linux
systems doesn't get effected by virus.
@end smallquotation

Well, that is usally true. And there
are a few reasons for this. First of
all, we designed it from the beginning
as a multiple user time sharing system.
These days of cause people usually run
it on a PC and there is only one user.
But it was designed for a large
computer that would be having five or
ten users at the same time. So it was
designed to keep them isolated from
each other and not let anybody destroy
the system. Where as Windows was not
designed for that. Second, Microsoft
persistently makes a really kind of
a decision where they run program
that arrive in files that you just
happen to have on your computers. So
of cause that makes it terrible
vulnerably to viruses.
And of cause there is also one other
factor: since Windows is more widely
used, virus writers prefers to attack
Windows. Well some day if the GNU+Linux
system is more popular we will lose
that advantage but we will still have
the other two.



@c BEGIN print indices
@node Concept and program index
@appendix Concept and program index
@printindex pg

@node Variable and option index
@appendix Variable and option index
@printindex vr
@c END print indices

@bye

